name: Build Unofficial VSIX Release

on:
  workflow_dispatch:
    inputs:
      notes:
        description: Additional release notes (optional)
        required: false

permissions:
  contents: write

jobs:
  version-info:
    name: Determine version metadata
    runs-on: ubuntu-22.04
    outputs:
      version: ${{ steps.propagate.outputs.version }}
      tag: ${{ steps.propagate.outputs.tag }}
      release_name: ${{ steps.propagate.outputs.release_name }}
      extension_version: ${{ steps.propagate.outputs.extension_version }}
      release_notes: ${{ steps.propagate.outputs.release_notes }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Determine next unofficial version
        id: determine
        uses: actions/github-script@v7
        with:
          script: |
            const { inspect } = require("util");
            const prefix = "vscode-unofficial-v";
            const releases = await github.paginate(github.rest.repos.listReleases, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });
            let max = 0;
            let previousRelease = null;
            for (const release of releases) {
              if (!release.tag_name?.startsWith(prefix)) continue;
              const numeric = Number.parseInt(release.tag_name.slice(prefix.length), 10);
              if (!Number.isNaN(numeric) && numeric > max) {
                max = numeric;
                previousRelease = release;
              }
            }
            const next = max + 1;
            const fs = require("fs");
            const path = require("path");
            const workspace = process.env.GITHUB_WORKSPACE ?? ".";
            const pkgPath = path.join(workspace, "extensions/vscode/package.json");
            const pkgContents = JSON.parse(fs.readFileSync(pkgPath, "utf8"));
            const baseVersion = String(pkgContents.version ?? "").replace(/-unofficial\.\d+$/, "");
            const extensionVersion = `${baseVersion}-unofficial.${next}`;
            const previousTag = previousRelease?.tag_name ?? "";
            let releaseNotes = "";
            if (previousTag) {
              try {
                const response = await github.rest.repos.generateReleaseNotes({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: `${prefix}${next}`,
                  target_commitish: context.sha,
                  previous_tag_name: previousTag,
                });
                releaseNotes = (response.data.body ?? "").trim();
              } catch (error) {
                core.warning(
                  `Failed to generate release notes using GitHub API: ${inspect(error)}`,
                );
                try {
                  const comparison = await github.rest.repos.compareCommitsWithBasehead({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    basehead: `${previousTag}...${context.sha}`,
                  });
                  const commits = comparison.data.commits ?? [];
                  if (commits.length > 0) {
                    releaseNotes = commits
                      .map((commit) => {
                        const message = commit.commit?.message ?? commit.message ?? "";
                        const firstLine = String(message).split(/\r?\n/, 1)[0];
                        const sha = commit.sha ? commit.sha.slice(0, 7) : "";
                        return sha ? `- ${firstLine} (${sha})` : `- ${firstLine}`;
                      })
                      .join("\n");
                  }
                } catch (compareError) {
                  core.warning(
                    `Failed to compare commits between ${previousTag} and ${context.sha}: ${inspect(compareError)}`,
                  );
                }
              }
            } else {
              releaseNotes =
                "This is the first unofficial VSIX release. All commits up to this point are included.";
            }
            releaseNotes = releaseNotes.replace(/\r\n/g, "\n").trim();
            if (!releaseNotes) {
              releaseNotes =
                "No commit differences were detected since the previous unofficial release.";
            }
            core.setOutput("version", String(next));
            core.setOutput("tag", `${prefix}${next}`);
            core.setOutput(
              "release_name",
              `Unofficial Continue VSIX Build v${next} (Not an official Continue release)`,
            );
            core.setOutput("extension_version", extensionVersion);
            core.setOutput("previous_tag", previousTag);
            core.setOutput("release_notes", releaseNotes);
            core.exportVariable("VERSION", String(next));
            core.exportVariable("TAG", `${prefix}${next}`);
            core.exportVariable(
              "RELEASE_NAME",
              `Unofficial Continue VSIX Build v${next} (Not an official Continue release)`,
            );
            core.exportVariable("EXTENSION_VERSION", extensionVersion);
            core.exportVariable("PREVIOUS_TAG", previousTag);
            core.exportVariable("RELEASE_NOTES", releaseNotes);

      - name: Propagate version metadata
        id: propagate
        run: |
          {
            echo "version=${VERSION}";
            echo "tag=${TAG}";
            echo "release_name=${RELEASE_NAME}";
            echo "extension_version=${EXTENSION_VERSION}";
            echo "previous_tag=${PREVIOUS_TAG}";
            echo "release_notes<<'EOF'";
            printf '%s\n' "${RELEASE_NOTES}";
            echo "EOF";
          } >> "$GITHUB_OUTPUT"

  build-linux:
    name: Build Linux VSIX
    runs-on: ubuntu-22.04
    needs: version-info
    outputs:
      artifact_name: ${{ steps.artifact-metadata.outputs.name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Update extension version metadata
        run: |
          set -euo pipefail
          cd extensions/vscode
          echo "Setting extension version to ${EXT_VERSION}"
          node <<'EOF'
          const fs = require('fs');
          const path = require('path');
          const version = process.env.EXT_VERSION;
          if (!version) {
            throw new Error('Missing EXT_VERSION environment variable');
          }
          const pkgPath = path.join(process.cwd(), 'package.json');
          const lockPath = path.join(process.cwd(), 'package-lock.json');
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          pkg.version = version;
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
          if (fs.existsSync(lockPath)) {
            const lock = JSON.parse(fs.readFileSync(lockPath, 'utf8'));
            lock.version = version;
            if (lock.packages && lock.packages['']) {
              lock.packages[''].version = version;
            }
            fs.writeFileSync(lockPath, JSON.stringify(lock, null, 2) + '\n');
          }
          EOF
        env:
          EXT_VERSION: ${{ needs.version-info.outputs.extension_version }}

      - name: Clean previous VSIX artifacts
        run: rm -f extensions/vscode/*.vsix

      - name: Build VS Code extension (linux x64)
        uses: ./.github/actions/build-vscode-extension
        with:
          platform: linux
          arch: x64
          npm_config_arch: x64
          pre-release: false
          commit-sha: ${{ github.sha }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare Linux VSIX artifact
        id: linux-vsix
        run: |
          set -euo pipefail
          mkdir -p extensions/vscode/unofficial
          shopt -s nullglob
          files=(extensions/vscode/*.vsix)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No VSIX file was generated." >&2
            exit 1
          fi
          VSIX="${files[0]}"
          TARGET="extensions/vscode/unofficial/continue-vscode-unofficial-linux-${{ needs.version-info.outputs.version }}.vsix"
          mv "$VSIX" "$TARGET"
          echo "vsix_path=$TARGET" >> $GITHUB_OUTPUT

      - name: Set artifact metadata
        id: artifact-metadata
        run: echo "name=continue-vscode-unofficial-linux-${{ needs.version-info.outputs.version }}" >> $GITHUB_OUTPUT

      - name: Upload Linux VSIX artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact-metadata.outputs.name }}
          path: ${{ steps.linux-vsix.outputs.vsix_path }}

  build-macos-arm64:
    name: Build macOS arm64 VSIX
    runs-on: macos-latest
    needs: version-info
    outputs:
      artifact_name: ${{ steps.artifact-metadata.outputs.name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Update extension version metadata
        run: |
          set -euo pipefail
          cd extensions/vscode
          echo "Setting extension version to ${EXT_VERSION}"
          node <<'EOF'
          const fs = require('fs');
          const path = require('path');
          const version = process.env.EXT_VERSION;
          if (!version) {
            throw new Error('Missing EXT_VERSION environment variable');
          }
          const pkgPath = path.join(process.cwd(), 'package.json');
          const lockPath = path.join(process.cwd(), 'package-lock.json');
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          pkg.version = version;
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
          if (fs.existsSync(lockPath)) {
            const lock = JSON.parse(fs.readFileSync(lockPath, 'utf8'));
            lock.version = version;
            if (lock.packages && lock.packages['']) {
              lock.packages[''].version = version;
            }
            fs.writeFileSync(lockPath, JSON.stringify(lock, null, 2) + '\n');
          }
          EOF
        env:
          EXT_VERSION: ${{ needs.version-info.outputs.extension_version }}

      - name: Clean previous VSIX artifacts
        run: rm -f extensions/vscode/*.vsix

      - name: Build VS Code extension (macOS arm64)
        uses: ./.github/actions/build-vscode-extension
        with:
          platform: darwin
          arch: arm64
          npm_config_arch: arm64
          pre-release: false
          commit-sha: ""
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare macOS arm64 VSIX artifact
        id: mac-arm-vsix
        run: |
          set -euo pipefail
          mkdir -p extensions/vscode/unofficial
          shopt -s nullglob
          files=(extensions/vscode/*.vsix)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No VSIX file was generated." >&2
            exit 1
          fi
          VSIX="${files[0]}"
          TARGET="extensions/vscode/unofficial/continue-vscode-unofficial-macos-arm64-${{ needs.version-info.outputs.version }}.vsix"
          mv "$VSIX" "$TARGET"
          echo "vsix_path=$TARGET" >> $GITHUB_OUTPUT

      - name: Set artifact metadata
        id: artifact-metadata
        run: echo "name=continue-vscode-unofficial-macos-arm64-${{ needs.version-info.outputs.version }}" >> $GITHUB_OUTPUT

      - name: Upload macOS arm64 VSIX artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact-metadata.outputs.name }}
          path: ${{ steps.mac-arm-vsix.outputs.vsix_path }}

  publish-release:
    name: Publish release
    runs-on: ubuntu-22.04
    needs:
      - version-info
      - build-linux
      - build-macos-arm64

    steps:
      - name: Download Linux VSIX artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-linux.outputs.artifact_name }}
          path: dist/linux

      - name: Register Linux VSIX path
        id: linux-path
        run: |
          set -euo pipefail
          shopt -s nullglob
          files=(dist/linux/*.vsix)
          if [ ${#files[@]} -eq 0 ]; then
            echo "Linux VSIX not found" >&2
            exit 1
          fi
          echo "path=${files[0]}" >> $GITHUB_OUTPUT

      - name: Download macOS arm64 VSIX artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-macos-arm64.outputs.artifact_name }}
          path: dist/macos-arm64

      - name: Register macOS arm64 VSIX path
        id: mac-arm64-path
        run: |
          set -euo pipefail
          shopt -s nullglob
          files=(dist/macos-arm64/*.vsix)
          if [ ${#files[@]} -eq 0 ]; then
            echo "macOS arm64 VSIX not found" >&2
            exit 1
          fi
          echo "path=${files[0]}" >> $GITHUB_OUTPUT

      - name: Compose release body
        run: |
          set -euo pipefail
          cat <<EOF > release-body.md
          This is an automatically generated **unofficial** Continue VSIX build for Linux x64 and macOS arm64.

          Version: v${RELEASE_VERSION}

          These builds are provided for convenience only and are **not** official Continue releases.
          EOF
          if [ -n "${RELEASE_NOTES:-}" ]; then
            {
              echo ""
              echo "## Changes since last release"
              echo ""
              printf '%s\n' "${RELEASE_NOTES}"
            } >> release-body.md
          fi
          if [ -n "${ADDITIONAL_NOTES:-}" ]; then
            {
              echo ""
              echo "## Additional notes"
              echo ""
              printf '%s\n' "${ADDITIONAL_NOTES}"
            } >> release-body.md
          fi
        env:
          RELEASE_VERSION: ${{ needs.version-info.outputs.version }}
          RELEASE_NOTES: ${{ needs.version-info.outputs.release_notes }}
          ADDITIONAL_NOTES: ${{ github.event.inputs.notes }}

      - name: Publish release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.version-info.outputs.tag }}
          name: ${{ needs.version-info.outputs.release_name }}
          body_path: release-body.md
          prerelease: true
          draft: false
          generate_release_notes: false
          files: |
            ${{ steps.linux-path.outputs.path }}
            ${{ steps.mac-arm64-path.outputs.path }}
